{
  "Nexus.js": "\n(function () {\n\tvar fs = require('fs');\n\tvar Path = require('path');\n\tlet log = fs.createWriteStream(process.cwd() + \"/EventLog.txt\");\n\n\tvar Uuid;\n\tvar CacheDir;\n\tvar WorkDir = process.cwd();\n\tvar Config = {};\n\tvar Apex = {};\t\t// {<Name>: <pid of Apex>}\n\tvar Modules = {};\t// {<Name>: <mod desc>} - only in Genesis\n\tvar ModCache = {};\t// {<folder>: <module>}\n\tvar ApexIndex = {}; // {<Apex pid>:<folder>}\n\tvar EntCache = {};\t// {<Entity pid>:<Entity>\n\tvar ImpCache = {};\t// {<Implementation path>: <Implementation(e.g. disp)>}\n\tvar package = {};\n\tvar Mod = {};\n\tvar Nxs = {\n\t\tEventLog: EventLog,\n\t\tgenPid: genPid,\n\t\tgenPath: genPath,\n\t\tGetModule,\n\t\tgenModule: genModule,\n\t\tgenEntity: genEntity,\n\t\tdeleteEntity: deleteEntity,\n\t\tgetParameter: getParameter,\n\t\tgetFile,\n\t\tsendMessage: sendMessage\n\t}\n\tEventLog('=================================================');\n\n\t// Process input arguments and define macro parameters\n\tvar args = process.argv;\n\tlet arg;\n\tlet parts;\n\tlet development = false;\n\tif (process.env.XGRAPH_ENV && process.env.XGRAPH_ENV.toLowerCase() === \"development\") {\n\t\tdevelopment = true;\n\t}\n\tlet Params = {};\n\tfor (var iarg = 0; iarg < args.length; iarg++) {\n\t\targ = args[iarg];\n\t\tEventLog(arg);\n\t\tparts = arg.split('=');\n\t\tif (parts.length == 2) {\n\t\t\tParams[parts[0]] = parts[1];\n\t\t\t//make way for development=true command line set\n\t\t\tif (parts[0] == 'development')\n\t\t\t\tdevelopment = (parts[1] === 'true');\n\t\t}\n\t}\n\n\tvar config = 'config.json';\n\tif ('Config' in Params)\n\t\tconfig = Params.Config;\n\tlet str = fs.readFileSync(config);\n\tlet val;\n\tif (str) {\n\t\tvar ini = JSON.parse(str);\n\t\tfor (key in ini) {\n\t\t\tval = ini[key];\n\t\t\tif (typeof val == 'string') {\n\t\t\t\tConfig[key] = Macro(val);\n\t\t\t\tParams[key] = Config[key];\n\t\t\t} else {\n\t\t\t\tConfig[key] = val;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tEventLog(' ** No configuration file provided');\n\t\tprocess.exit(1);\n\t}\n\tEventLog(JSON.stringify(Config, null, 2));\n\n\tCacheDir = 'cache';\n\tif ('Cache' in Params)\n\t\tCacheDir = Params.Cache;\n\t//\tremDir(CacheDir); // REMOVE REMOVE REMOVE REMOVE REMOVE REMOVE REMOVE\n\tif (!fs.existsSync(CacheDir)) {\n\t\tdevelopment = false;\n\t\tGenesis(Initiate);\n\t} else {\n\t\tInitiate(Run);\n\t}\n\n\tfunction EventLog(string) {\n\t\t//event log only built to handle strings\n\t\t//write them out\n\t\tlog.write(string + \"\\n\");\n\t\t//currently we also write it to the console,this will not always exist\n\t\tconsole.log(string);\n\t}\n\n\t//-----------------------------------------------------Run\n\tfunction Run() {\n\t\tEventLog('\\n--Nexus/Run');\n\t\tif ('send' in process) {\n\t\t\tprocess.send('{\"Cmd\":\"Finished\"}');\n\t\t}\n\t}\n\n\t//-----------------------------------------------------remDir\n\t// Shake well before using\n\t// Recursive directory deletion\n\tfunction remDir(path) {\n\t\tvar files = [];\n\t\tif (fs.existsSync(path)) {\n\t\t\tfiles = fs.readdirSync(path);\n\t\t\tfiles.forEach(function (file, index) {\n\t\t\t\tvar curPath = path + \"/\" + file;\n\t\t\t\tif (fs.lstatSync(curPath).isDirectory()) { // recurse\n\t\t\t\t\tconsole.log('Deleting folder:' + curPath);\n\t\t\t\t\tremDir(curPath);\n\t\t\t\t} else { // delete file\n\t\t\t\t\tconsole.log('Deleting file:' + curPath);\n\t\t\t\t\tfs.unlinkSync(curPath);\n\t\t\t\t}\n\t\t\t});\n\t\t\tconsole.log('Deleting folder:' + path);\n\t\t\tfs.rmdirSync(path);\n\t\t}\n\t}\n\t//---------------------------------------------------------genPid\n\t// Create a new PID\n\tfunction genPid() {\n\t\tif (!Uuid)\n\t\t\tUuid = require('node-uuid');\n\t\tvar str = Uuid.v4();\n\t\tvar pid = str.replace(/-/g, '').toUpperCase();\n\n\t\treturn pid;\n\t}\n\n\t//---------------------------------------------------------genPath\n\tfunction genPath(filein) {\n\t\t//\tEventLog('!!genPath', filein);\n\t\tif (!filein) {\n\t\t\tEventLog(' ** ERR:Invalid file name');\n\t\t\treturn '';\n\t\t}\n\t\tvar cfg = Config;\n\t\tvar path;\n\t\tvar parts;\n\t\tvar file = filein;\n\t\tif (Config.Redirect) {\n\t\t\tif (file in Config.Redirect)\n\t\t\t\tfile = Config.Redirect[file];\n\t\t}\n\t\tif (file.charAt(0) == '/')\n\t\t\treturn file;\n\t\tif (file.charAt(0) == '{') { // Macro\n\t\t\tparts = file.split('}');\n\t\t\tif (parts.length != 2) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar name = parts[0].substr(1);\n\t\t\tif (name in cfg) {\n\t\t\t\tpath = cfg[name] + '/' + parts[1];\n\t\t\t\treturn path;\n\t\t\t} else {\n\t\t\t\tEventLog(' ** ERR:File <' + file + '> {' + name + '} not found');\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tparts = file.split(':');\n\t\tif (parts.length == 2) {\n\t\t\tif (parts[0] in cfg) {\n\t\t\t\tpath = cfg[parts[0]] + '/' + parts[1];\n\t\t\t} else {\n\t\t\t\tEventLog(' ** ERR:File <' + file + '> prefix not defined');\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tpath = file;\n\t\t}\n\t\treturn path;\n\t}\n\n\tfunction Macro(str) {\n\t\tlet state = 1;\n\t\tlet chr;\n\t\tlet s = '';\n\t\tlet param;\n\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\tchr = str.charAt(i);\n\t\t\tswitch (state) {\n\t\t\t\tcase 1:\n\t\t\t\t\tif (chr == '{') {\n\t\t\t\t\t\tparam = '';\n\t\t\t\t\t\tstate = 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ts += chr;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tif (chr == '}') {\n\t\t\t\t\t\tif (param in Params)\n\t\t\t\t\t\t\ts += Params[param];\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tthrow 'Parameter <' + param + '> not defined';\n\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparam += chr;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (state != 1)\n\t\t\tthrow 'Curley brackets not matched in __Macro';\n\t\treturn s;\n\t}\n\n\t//-----------------------------------------------------send\n\t// Send message to an entity in the current systems (bag)\n\t// If call back provided, return to sender\n\tfunction sendMessage(com, fun) {\n\t\t//console.log('--sendMessage', com.Cmd);\n\t\tif (!('Passport' in com)) {\n\t\t\tEventLog(' ** ERR:Message has no Passport, ignored');\n\t\t\tEventLog('    ' + JSON.stringify(com));\n\t\t\tif (fun)\n\t\t\t\tfun('No Passport');\n\t\t\treturn;\n\t\t}\n\t\tif (!('To' in com.Passport) || !com.Passport.To) {\n\t\t\tEventLog(' ** ERR:Message has no destination entity, ignored');\n\t\t\tEventLog('    ' + JSON.stringify(com));\n\t\t\tconsole.trace();\n\t\t\tif (fun)\n\t\t\t\tfun('No recipient in message', com);\n\t\t\treturn;\n\t\t}\n\t\tif (!('Pid' in com.Passport)) {\n\t\t\tEventLog(' ** ERR:Message has no message id, ignored');\n\t\t\tEventLog('    ' + JSON.stringify(com));\n\t\t\tif (fun)\n\t\t\t\tfun('No message id', com);\n\t\t\treturn;\n\t\t}\n\n\t\tvar pid = com.Passport.To;\n\t\tif (pid in EntCache) {\n\t\t\tvar ent = EntCache[pid];\n\t\t\tent.dispatch(com, reply);\n\t\t\treturn;\n\t\t}\n\t\tif (pid in ApexIndex) {\n\t\t\t//console.log('In ApexIndex');\n\t\t\tgetEntity(pid, pid, done);\n\t\t\treturn;\n\t\t}\n\t\tvar apx;\n\t\tif ('Apex' in com.Passport)\n\t\t\tapx = com.Passport.Apex;\n\t\telse\n\t\t\tapx = pid;\n\t\tgetEntity(apx, pid, done);\n\n\t\tfunction done(err, ent) {\n\t\t\tif (err) {\n\t\t\t\tEventLog(' ** ERR:' + err);\n\t\t\t\tconsole.log(JSON.stringify(com, null, 2));\n\t\t\t\tif (fun)\n\t\t\t\t\tfun(err, com);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tent.dispatch(com, reply);\n\t\t\treturn;\n\t\t}\n\n\t\tfunction reply(err, q) {\n\t\t\t//\tEventLog('..Nexus/send/reply', com.Cmd, com.Passport);\n\t\t\tif (fun)\n\t\t\t\tfun(err, q);\n\t\t}\n\t}\n\n\t//-----------------------------------------------------getParameter\n\t// Retrieve command line parameter\n\tfunction getParameter(name) {\n\t\tEventLog('--Nexus/GetParameter');\n\t\tEventLog('Params', JSON.stringify(Params, null, 2));\n\t\tif (name in Params)\n\t\t\treturn Params[name];\n\t}\n\n\t//-----------------------------------------------------Entity\n\t// This is the entity base class that is used to create\n\t// new entities.\n\tfunction Entity(nxs, imp, par) {\n\t\tvar Par = par;\n\t\tvar Imp = imp;\n\t\tvar Vlt = {};\n\n\t\treturn {\n\t\t\tPar: Par,\n\t\t\tVlt: Vlt,\n\t\t\tdispatch: dispatch,\n\t\t\tgenModule: genModule,\n\t\t\tgetModule,\n\t\t\tgenEntity: genEntity,\n\t\t\tdeleteEntity: deleteEntity,\n\t\t\tgenPid: genPid,\n\t\t\tgenPath: genPath,\n\t\t\tsend: send,\n\t\t\tsave: save,\n\t\t\tgetPid: getPid,\n\t\t\tgetFile,\n\t\t\tlog: log,\n\t\t\trequire\n\t\t};\n\n\t\t//log data to EventLog.txt in the current working directory\n\t\t//this log only works with a single string \n\t\tfunction log(string) {\n\t\t\t//we will write to the eventlog if this.log was misused\n\t\t\tif (arguments.length > 1) {\n\t\t\t\tnxs.EventLog(\"Error: Message may be incomplete\\n\" +\n\t\t\t\t\t\"more than one argument was passed to this.log()\");\n\t\t\t}\n\t\t\tnxs.EventLog(string);\n\t\t}\n\n\t\tfunction getFile(filename, fun) {\n\t\t\tnxs.EventLog(`Entity - Getting file ${filename} from ${Par.Module}`);\n\t\t\tnxs.getFile(Par.Module, filename, fun);\n\t\t}\n\n\t\tfunction getModule(modulename, fun) {\n\n\t\t\tnxs.EventLog(`Entity - Getting module ${modulename}`);\n\t\t\tnxs.GetModule(modulename, fun);\n\t\t}\n\n\t\t//-------------------------------------------------dispatch\n\t\t// Used by Nexus to dispatch messages\n\t\tfunction dispatch(com, fun) {\n\n\t\t\t//\tEventLog(Mod);\n\t\t\t//  EventLog('||dispatch', com.Cmd);\n\t\t\tvar disp = Imp.dispatch;\n\t\t\tif (com.Cmd in disp) {\n\t\t\t\tdisp[com.Cmd].call(this, com, fun);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ('*' in disp) {\n\t\t\t\tdisp['*'].call(this, com, fun);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tnxs.EventLog(' ** ERR:Nada Cmd:' + com.Cmd);\n\t\t\tfun('Nada', com);\n\t\t}\n\n\t\t//-------------------------------------------------genModule\n\t\t// Generate module and return (err, pidapx);\n\t\tfunction genModule(mod, fun) {\n\t\t\t//\tEventLog('--Entity/genModule');\n\t\t\tnxs.genModule(mod, fun);\n\t\t}\n\n\n\t\tfunction deleteEntity(fun) {\n\t\t\t//EventLog(\"DElElTingASDF\")\n\t\t\tnxs.deleteEntity(Par.Pid, fun);\n\t\t}\n\n\t\tfunction genEntity(par, fun) {\n\t\t\tnxs.genEntity(par, fun);\n\t\t}\n\n\t\tfunction genPid() {\n\t\t\tlet pid = nxs.genPid();\n\t\t\treturn pid;\n\t\t}\n\n\t\tfunction genPath(mod) {\n\t\t\tlet path = nxs.genPath(mod);\n\t\t\treturn path;\n\t\t}\n\n\t\t//-------------------------------------------------send\n\t\t// Send message to another entity which can be in another\n\t\t// bag or browser. Callback when message is returned\n\t\tfunction send(com, pid, fun) {\n\n\t\t\tif (!('Passport' in com))\n\t\t\t\tcom.Passport = {};\n\t\t\tcom.Passport.To = pid;\n\t\t\tif ('Apex' in Par)\n\t\t\t\tcom.Passport.Apex = Par.Apex;\n\t\t\tif (fun)\n\t\t\t\tcom.Passport.From = Par.Pid;\n\t\t\tif (!(\"Pid\" in com.Passport))\n\t\t\t\tcom.Passport.Pid = genPid();\n\t\t\tnxs.sendMessage(com, fun);\n\t\t}\n\n\t\t//-------------------------------------------------save\n\t\t// Save entity in Cache\n\t\tfunction save(fun) {\n\t\t\tconsole.log('--Nexus/save');\n\t\t\tvar path = CacheDir + '/';\n\t\t\tpath += Par.Module + '/';\n\t\t\tpath += Par.Apex + '/';\n\t\t\tpath += Par.Pid + '.json';\n\t\t\tvar str = JSON.stringify(Par, null, 2);\n\t\t\tconsole.log(str);\n\t\t\tfs.writeFile(path, str, done);\n\n\t\t\tfunction done(err) {\n\t\t\t\tif (fun)\n\t\t\t\t\tfun(err);\n\t\t\t}\n\t\t}\n\n\t\t//-------------------------------------------------getPid\n\t\t// Return Pid of entity\n\t\tfunction getPid() {\n\t\t\treturn Par.Pid;\n\t\t}\n\n\t}\n\n\t//-----------------------------------------------------genEntity\n\t// Create entity from parameter object in current module\n\tfunction genEntity(par, fun) {\n\t\tEventLog(' ** ERR:genEntity not implemented');\n\t\tfun('genEntity not implmeneted');\n\t}\n\n\tfunction deleteEntity(pid, fun) {\n\t\tEventLog(' ** ERR:deleteEntity not implemented');\n\t\tfun('deleteEntity not implmeneted');\n\t}\n\n\tfunction getFile(module, filename, fun) {\n\t\tlet mod = ModCache[module];\n\t\t//console.log(Object.keys(ModCache[module]));\n\t\tif (filename in mod) {\n\t\t\tfun(null, mod[filename])\n\t\t\treturn;\n\t\t}\n\t\tlet err = `Error: File ${filename} does not exist in module ${module}`;\n\t\tEventLog(err);\n\t\tfun(err);\n\t}\n\n\t//-----------------------------------------------------getEntity\n\tfunction getEntity(apx, pid, fun) {\n\t\tvar imp;\n\t\tvar par;\n\t\tvar ent;\n\n\t\t// If entity already cached, just return it\n\t\tif (pid in EntCache) {\n\t\t\tent = EntCache[pid];\n\t\t\tfun(null, ent);\n\t\t\treturn;\n\t\t}\n\n\t\t// Check to see if Apex entity in this system\n\t\tif (!(apx in ApexIndex)) {\n\t\t\t//\tEventLog(' ** ERR:Pid <' + pid + '> not Apex in system');\n\t\t\tfun('Not available');\n\t\t\treturn;\n\t\t}\n\t\tvar folder = ApexIndex[apx];\n\t\tvar path = CacheDir + '/' + folder + '/' + apx + '/' + pid + '.json';\n\t\tfs.readFile(path, function (err, data) {\n\t\t\tif (err) {\n\t\t\t\tconsole.log(' ** ERR:<' + path + '> unavailable');\n\t\t\t\tif (fun)\n\t\t\t\t\tfun('Unavailable');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar par = JSON.parse(data.toString());\n\t\t\tvar impkey = folder + '/' + par.Entity;\n\t\t\tif (impkey in ImpCache) {\n\t\t\t\tvar imp = ImpCache[impkey];\n\t\t\t\tvar ent = new Entity(Nxs, imp, par);\n\t\t\t\tEntCache[pid] = ent;\n\t\t\t\tfun(null, ent);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//debugger;\n\t\t\tGetModule(folder, function (err, mod) {\n\t\t\t\tif (err) {\n\t\t\t\t\tconsole.log(' ** ERR:Module <' + folder + '> not available');\n\t\t\t\t\tif (fun)\n\t\t\t\t\t\tfun('Module not available');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!(par.Entity in mod)) {\n\t\t\t\t\tconsole.log(' ** ERR:<' + par.Entity + '> not in module <' + folder + '>');\n\t\t\t\t\tif (fun)\n\t\t\t\t\t\tfun('Null entity');\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tvar imp = (1, eval)(mod[par.Entity]);\n\t\t\t\tImpCache[impkey] = imp;\n\t\t\t\tvar ent = new Entity(Nxs, imp, par);\n\t\t\t\tEntCache[pid] = ent;\n\t\t\t\tfun(null, ent);\n\t\t\t});\n\t\t});\n\t}\n\n\t//-------------------------------------------------genModule\n\t// This is the version used to install modules\n\t// after startup, such as web dashboards and such.\n\t// It provides for safe setup and start which is\n\t// handled by Nxs for modules instantiated initially.\n\t// TBD: If modules saved, Initializers will need to be\n\t//      added to the Start and Setup lists in Root\n\tfunction genModule(inst, fun) {\n\t\tvar that = this;\n\t\tvar modnam = inst.Module;\n\t\tGetModule(modnam, function (err, mod) {\n\t\t\tif (err) {\n\t\t\t\tconsole.log(' ** ERR:GenModule err -', err);\n\t\t\t\tif (fun)\n\t\t\t\t\tfun(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar pidapx = genPid();\n\t\t\tvar ents = compileInstance(pidapx, inst);\n\t\t\tents.forEach(function (par) {\n\t\t\t\tlet impkey = modnam + par.Entity;\n\t\t\t\tvar imp;\n\t\t\t\tif (impkey in ImpCache) {\n\t\t\t\t\timp = ImpCache[impkey];\n\t\t\t\t} else {\n\t\t\t\t\timp =  (1, eval)(mod[par.Entity]);\n\t\t\t\t\tImpCache[impkey] = imp;\n\t\t\t\t}\n\t\t\t\tvar ent = new Entity(Nxs, imp, par);\n\t\t\t\tEntCache[par.Pid] = ent;\n\t\t\t});\n\t\t\tif (fun) {\n\t\t\t\tfun(null, pidapx);\n\t\t\t}\n\t\t});\n\t}\n\n\t//-----------------------------------------------------Genesis\n\t// Create cache if it does nto exist and populate\n\t// This is called only once when a new systems is\n\t// first instantiated\n\tfunction Genesis(fun) {\n\t\tEventLog('--Nexus/Genesis');\n\t\tvar Folders = [];\n\n\t\t// Create new cache and install high level\n\t\t// module subdirectories. Each of these also\n\t\t// has a link to the source of that module,\n\t\t// at this point a local file directory, but\n\t\t// eventually this should be some kind of\n\t\t// alternate repository (TBD)\n\t\tvar keys = Object.keys(Config.Modules);\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tlet key = keys[i];\n\t\t\tif (key == 'Deferred') {\n\t\t\t\tvar arr = Config.Modules[key];\n\t\t\t\tarr.forEach(function (folder) {\n\t\t\t\t\tif (Folders.indexOf(folder) < 0)\n\t\t\t\t\t\tFolders.push(folder);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tvar mod = {};\n\t\t\t\t//console.log('mod', mod);\n\t\t\t\tlet folder = Config.Modules[key].Module.replace(/\\//g, '.').replace(/:/g, '.');\n\t\t\t\tif (Folders.indexOf(folder) < 0)\n\t\t\t\t\tFolders.push(folder);\n\t\t\t}\n\t\t}\n\t\t//console.log('Folders', Folders);\n\t\tlet nfolders = Folders.length;\n\t\tlet ifolder = -1;\n\t\tnext();\n\n\t\tfunction next() {\n\t\t\tifolder++;\n\t\t\tif (ifolder >= nfolders) {\n\t\t\t\trefreshSystem(populate);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet folder = Folders[ifolder];\n\t\t\tGetModule(folder, function (err, mod) {\n\t\t\t\tModCache[folder] = mod;\n\t\t\t\tnext();\n\t\t\t});\n\t\t}\n\n\t\tfunction populate() {\n\t\t\tconsole.log('--populate');\n\t\t\t// Build cache structure and Module.json\n\t\t\tfs.mkdirSync(CacheDir);\n\t\t\tfor (let folder in ModCache) {\n\t\t\t\tconsole.log(folder);\n\t\t\t\tvar mod = ModCache[folder];\n\t\t\t\tif ('schema.json' in mod) {\n\t\t\t\t\tvar schema = JSON.parse(mod['schema.json']);\n\t\t\t\t\tconsole.log('schema', JSON.stringify(schema, null, 2));\n\t\t\t\t\tif ('Apex' in schema) {\n\t\t\t\t\t\tvar apx = schema.Apex;\n\t\t\t\t\t\tif ('$Setup' in apx)\n\t\t\t\t\t\t\tmod.Setup = apx['$Setup'];\n\t\t\t\t\t\tif ('$Start' in apx)\n\t\t\t\t\t\t\tmod.Start = apx['$Start'];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar dir = CacheDir + '/' + folder;\n\t\t\t\tfs.mkdirSync(dir);\n\t\t\t\tpath = dir + '/Module.json';\n\t\t\t\tvar str = JSON.stringify(ModCache[folder]);\n\t\t\t\tfs.writeFileSync(path, str);\n\t\t\t\tvar path = dir + '/Module.json';\n\t\t\t\tfs.writeFileSync(path, JSON.stringify(mod, null, 2));\n\t\t\t\t//console.log(Object.keys(mod));\n\t\t\t}\n\n\t\t\t// Assign pids to all instance in Configu.Modules\n\t\t\tfor (let instname in Config.Modules) {\n\t\t\t\t//debugger;\n\t\t\t\tApex[instname] = genPid();\n\t\t\t}\n\t\t\t//console.log('Apex', Apex);\n\n\t\t\t// Now populate all of the modules from config.json\n\t\t\tfor (let instname in Config.Modules) {\n\t\t\t\tif (instname === 'Deferred')\n\t\t\t\t\tcontinue;\n\t\t\t\tif (instname === 'Nexus')\n\t\t\t\t\tcontinue;\n\t\t\t\tvar inst = Config.Modules[instname];\n\t\t\t\tconsole.log(instname, inst);\n\t\t\t\tvar pidinst = Apex[instname];\n\t\t\t\tvar ents = compileInstance(pidinst, inst);\n\t\t\t\tfolder = inst.Module;\n\t\t\t\t// The following is for backword compatibility only\n\t\t\t\tvar folder = folder.replace(/\\:/, '.').replace(/\\//g, '.');\n\t\t\t\tvar dirinst = CacheDir + '/' + folder + '/' + pidinst;\n\t\t\t\tfs.mkdirSync(dirinst);\n\t\t\t\tents.forEach(function (ent) {\n\t\t\t\t\tlet path = dirinst + '/' + ent.Pid + '.json';\n\t\t\t\t\t//console.log('entity path', path);\n\t\t\t\t\t//console.log('ent', ent);\n\t\t\t\t\tfs.writeFileSync(path, JSON.stringify(ent, null, 2));\n\t\t\t\t});\n\t\t\t}\n\t\t\t//\tprocess.exit(0);\n\t\t\tInitiate(Run);\n\t\t}\n\t}\n\n\t//----------------------------------------------------=CompileMOdule\n\t// Generate array of entities from module\n\t// Module must be in cache to allow use by both Genesis and\n\t// GenModule\n\t// The first parameter is the pid assigned to the Apex\n\tfunction compileInstance(pidapx, inst) {\n\t\tvar Local = {};\n\t\tvar modnam = inst.Module;\n\t\t//debugger;\n\t\tvar mod;\n\t\tvar ents = [];\n\t\t// The following is for backword compatibility only\n\t\tvar modnam = modnam.replace(/\\:/, '.').replace(/\\//g, '.');\n\t\tif (modnam in ModCache) {\n\t\t\tmod = ModCache[modnam];\n\t\t} else {\n\t\t\tconsole.log(' ** ERR:' + 'Module <' + modnam + '> not in ModCache');\n\t\t\treturn;\n\t\t}\n\t\tvar schema = JSON.parse(mod['schema.json']);\n\t\tvar entkeys = Object.keys(schema);\n\t\t//console.log('entkeys', entkeys);\n\t\tLocal = {};\n\t\tfor (j = 0; j < entkeys.length; j++) {\n\t\t\tlet entkey = entkeys[j];\n\t\t\tif (entkey === 'Apex')\n\t\t\t\tLocal[entkey] = pidapx;\n\t\t\telse\n\t\t\t\tLocal[entkey] = genPid();\n\t\t}\n\t\t//console.log('Local', Local);\n\t\tfor (j = 0; j < entkeys.length; j++) {\n\t\t\tlet entkey = entkeys[j];\n\t\t\tlet ent = schema[entkey];\n\t\t\tent.Pid = Local[entkey];\n\t\t\tif (entkey == 'Apex' && 'Par' in inst) {\n\t\t\t\tvar pars = Object.keys(inst.Par);\n\t\t\t\tfor (var ipar = 0; ipar < pars.length; ipar++) {\n\t\t\t\t\tvar par = pars[ipar];\n\t\t\t\t\tent[par] = inst.Par[par];\n\t\t\t\t}\n\t\t\t}\n\t\t\tent.Module = modnam;\n\t\t\tent.Apex = pidapx;\n\t\t\tvar pars = Object.keys(ent);\n\t\t\tfor (ipar = 0; ipar < pars.length; ipar++) {\n\t\t\t\tvar par = pars[ipar];\n\t\t\t\tvar val = ent[par];\n\t\t\t\tswitch (typeof val) {\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tent[par] = symbol(val);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'object':\n\t\t\t\t\t\tparseObject(val);\n\n\t\t\t\t\t\tfunction parseObject(val) {\n\t\t\t\t\t\t\tif (Array.isArray(val)) {\n\t\t\t\t\t\t\t\tfor (let ival = 0; ival < val.length; ival++) {\n\t\t\t\t\t\t\t\t\tif (typeof val[ival] === 'object')\n\t\t\t\t\t\t\t\t\t\tparseObject(val[key]);\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tval[ival] = symbol(val[ival]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (let key in val) {\n\t\t\t\t\t\t\t\t\tif (typeof val[key] === 'object')\n\t\t\t\t\t\t\t\t\t\tparseObject(val[key]);\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tval[key] = symbol(val[key]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tents.push(ent);\n\t\t}\n\t\treturn ents;\n\n\t\tfunction symbol(val) {\n\t\t\t//console.log(typeof val);\n\t\t\tif ((typeof val) !== 'string')\n\t\t\t\treturn val;\n\t\t\tvar sym = val.substr(1);\n\t\t\tif (val.charAt(0) === '$' && sym in Apex)\n\t\t\t\treturn Apex[sym];\n\t\t\tif (val.charAt(0) === '#' && sym in Local)\n\t\t\t\treturn Local[sym];\n\t\t\treturn val;\n\t\t}\n\t}\n\n\tfunction refreshSystem(func) {\n\t\t// Clean up all of the files from the\n\t\t// previous refresh. This is most important\n\t\t// for the package.json and node_modeuls dir\n\t\tconsole.log('--refreshSystems');\n\t\t//debugger;\n\t\tvar files = fs.readdirSync(WorkDir);\n\t\tfor (let i = 0; i < files.length; i++) {\n\t\t\tlet file = files[i];\n\t\t\tvar path = WorkDir + '/' + file;\n\t\t\tswitch (file) {\n\t\t\t\tcase 'cache':\n\t\t\t\tcase 'config.json':\n\t\t\t\tcase 'browser.json':\n\t\t\t\t\t//\tconsole.log('Keeping:' + path);\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (fs.lstatSync(path).isDirectory()) { // recurse\n\t\t\t\t// remDir(path);\n\t\t\t\t//\tdeleteFolderRecursive(curPath);\n\t\t\t} else { // delete file\n\t\t\t\t//\tconsole.log('Deleting file:' + path);\n\t\t\t\t//\tfs.unlinkSync(path);\n\t\t\t}\n\t\t}\n\n\t\t// Reconstruct package.json and nod_modules\n\t\t// directory by merging package.json of the\n\t\t// individual modules and then running npm\n\t\t// to create node_modules directory for system\n\t\tvar package;\n\t\t//console.log('ModeCache', ModCache);\n\t\tfor (let folder in ModCache) {\n\t\t\tlet mod = ModCache[folder];\n\t\t\tif ('package.json' in mod) {\n\t\t\t\tobj = JSON.parse(mod['package.json']);\n\t\t\t\t//console.log('Input', obj);\n\t\t\t\tif (!package) {\n\t\t\t\t\tpackage = obj;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t//console.log('A');\n\t\t\t\tif (obj.dependencies) {\n\t\t\t\t\t//console.log('B');\n\t\t\t\t\tif (!package.dependencies) package.dependencies = {};\n\t\t\t\t\tfor (key in obj.dependencies) {\n\t\t\t\t\t\t//console.log('key', key);\n\t\t\t\t\t\tif (!(key in package.dependencies))\n\t\t\t\t\t\t\tpackage.dependencies[key] = obj.dependencies[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (obj.devDependencies) {\n\t\t\t\t\tif (!package.devDependencies) package.devDependencies = {};\n\t\t\t\t\tfor (key in obj.devDependencies) {\n\t\t\t\t\t\tif (!(key in package.devDependencies))\n\t\t\t\t\t\t\tpackage.devDependencies[key] = obj.devDependencies[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//console.log('output', package);\n\t\t\t}\n\t\t}\n\t\tvar strout = JSON.stringify(package, null, 2);\n\t\tfs.writeFileSync('package.json', strout);\n\t\tconst proc = require('child_process');\n\t\tvar npm = (process.platform === \"win32\" ? \"npm.cmd\" : \"npm\");\n\t\tvar ps = proc.spawn(npm, ['install']);\n\n\t\tps.on('err', function (err) {\n\t\t\tEventLog('Failed to start child process.');\n\t\t\tEventLog('err:' + err);\n\t\t});\n\n\t\tps.on('exit', function (code) {\n\t\t\tEventLog('npm process exited with code:' + code);\n\t\t\tEventLog('Current working directory: ' + process.cwd());\n\t\t\tfunc();\n\t\t});\n\t}\n\n\t//-----------------------------------------------------GetModule\n\t// This is a surrogate for an eventual Module Server. This\n\t// code should be useful in developing such.\n\t// Because Nexus during Genesis does not have zip capability,\n\t// it relies on the Module Server to deliver content in that form.\n\t// Module Server names use dot notiation as in domain.family.module\n\t// where..\n\t//    domain is a major domain name such as 'xCraft2\", or 'xGraph'\n\t//    family is a grouping withing the domain such as 'Widgets'\n\t//    module is the name withing that group which can be further\n\t//        separated by dots as desired\n\tfunction GetModule(modnam, fun) {\n\t\tconsole.log('##GetModule', modnam);\n\t\t//debugger;\n\t\tvar ModName = modnam.replace(/\\:/, '.').replace(/\\//g, '.');\n\t\tvar dir = ModName.replace('.', ':').replace(/\\./g, '/');\n\t\tvar ModPath = genPath(dir);\n\t\tif (ModName in ModCache) {\n\t\t\tfun(null, ModCache[ModName]);\n\t\t\treturn;\n\t\t}\n\n\t\tvar cachedMod = `${CacheDir}/${ModName}/Module.json`;\n\t\t//console.log(\"looking in dir\", dir);\n\t\tfs.lstat(cachedMod, function (err, stat) {\n\t\t\tif (stat && !development) {\n\t\t\t\tif (!stat.isDirectory()) {\n\t\t\t\t\tfs.readFile(cachedMod, function (err, data) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tfun(err);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tModCache[ModName] = JSON.parse(data.toString());\n\t\t\t\t\t\tfun(null, ModCache[ModName]);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t//\n\t\t\t\t//\n\t\t\t\t//\n\t\t\t\t//\t\tAccess from the Broker!!!!!\n\t\t\t\t//\n\t\t\t\t//\n\t\t\t\t//\n\t\t\t\t//debugger;\n\t\t\t\tvar mod = {};\n\t\t\t\tfs.readdir(ModPath, function (err, files) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tconsole.log(' ** ERR:Module <' + ModPath + '? not available');\n\t\t\t\t\t\tfun(err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tvar nfile = files.length;\n\t\t\t\t\tvar ifile = -1;\n\t\t\t\t\tscan();\n\n\t\t\t\t\tfunction scan() {\n\t\t\t\t\t\tifile++;\n\t\t\t\t\t\tif (ifile >= nfile) {\n\t\t\t\t\t\t\tmod.ModName = ModName;\n\t\t\t\t\t\t\tModCache[ModName] = mod;\n\t\t\t\t\t\t\tfun(null, ModCache[ModName]);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar file = files[ifile];\n\t\t\t\t\t\tvar path = ModPath + '/' + file;\n\t\t\t\t\t\tfs.lstat(path, function (err, stat) {\n\t\t\t\t\t\t\tif (stat) {\n\t\t\t\t\t\t\t\tif (!stat.isDirectory()) {\n\t\t\t\t\t\t\t\t\tfs.readFile(path, function (err, data) {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tfun(err);\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tmod[file] = data.toString();\n\t\t\t\t\t\t\t\t\t\tscan();\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tscan();\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t//-----------------------------------------------------Initialize\n\tasync function Initiate(fun) {\n\t\tEventLog('\\n--Nexus/Initiate');\n\t\tlet refresh = false;\n\t\tModules = {};\n\t\tApexIndex = {};\n\t\tvar Setup = {};\n\t\tvar Start = {};\n\t\tvar folders = fs.readdirSync(CacheDir);\n\t\t//console.log('folders', folders);\n\t\t//debugger;\n\t\tfor (var ifold = 0; ifold < folders.length; ifold++) {\n\t\t\tvar folder = folders[ifold];\n\t\t\tvar dir = CacheDir + '/' + folder;\n\t\t\tif (!fs.lstatSync(dir).isDirectory())\n\t\t\t\tcontinue;\n\t\t\tvar path = dir + '/Module.json';\n\n\t\t\tif (!fs.existsSync(path) || development) {\n\t\t\t\tlet mod = await new Promise((resolve, reject) => {\n\t\t\t\t\tGetModule(folder, (err, mod) => {\n\t\t\t\t\t\tif (err)\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tresolve(mod);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tif ('schema.json' in mod) {\n\t\t\t\t\tvar schema = JSON.parse(mod['schema.json']);\n\t\t\t\t\tconsole.log('schema', JSON.stringify(schema, null, 2));\n\t\t\t\t\tif ('Apex' in schema) {\n\t\t\t\t\t\tvar apx = schema.Apex;\n\t\t\t\t\t\tif ('$Setup' in apx)\n\t\t\t\t\t\t\tmod.Setup = apx['$Setup'];\n\t\t\t\t\t\tif ('$Start' in apx)\n\t\t\t\t\t\t\tmod.Start = apx['$Start'];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trefresh = true;\n\t\t\t\tif (!fs.existsSync(path) && !development) {\n\t\t\t\t\tfs.writeFileSync(path, JSON.stringify(mod, null, 2));\n\t\t\t\t\tEventLog('WARNING: Replaced Missing Module.json at ' + path);\n\t\t\t\t}\n\t\t\t\tparseMod(mod, dir, folder);\n\n\t\t\t} else {\n\t\t\t\tvar data = fs.readFileSync(path).toString();\n\t\t\t\tvar mod = JSON.parse(data);\n\t\t\t\tparseMod(mod, dir, folder);\n\t\t\t}\n\n\t\t\tfunction parseMod(mod, dir, folder) {\n\t\t\t\t//console.log('mod', JSON.stringify(mod, null, 2));\n\t\t\t\tModules[folder] = mod;\n\t\t\t\tvar files = fs.readdirSync(dir);\n\t\t\t\tfor (var ifile = 0; ifile < files.length; ifile++) {\n\t\t\t\t\tvar file = files[ifile];\n\t\t\t\t\tif (file.length !== 32)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvar path = dir + '/' + file;\n\t\t\t\t\tif (fs.lstatSync(path).isDirectory()) {\n\t\t\t\t\t\tApexIndex[file] = folder;\n\t\t\t\t\t\tif ('Setup' in mod)\n\t\t\t\t\t\t\tSetup[file] = mod.Setup;\n\t\t\t\t\t\tif ('Start' in mod)\n\t\t\t\t\t\t\tStart[file] = mod.Start;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//console.log('ApexIndex', ApexIndex);\n\t\t}\n\t\t//console.log('Modules', JSON.stringify(Modules, null, 2));\n\t\tconsole.log('ApexIndex', JSON.stringify(ApexIndex, null, 2));\n\t\tconsole.log('Setup', JSON.stringify(Setup, null, 2));\n\t\tconsole.log('Start', JSON.stringify(Start, null, 2));\n\n\t\t// Setup\n\t\tvar ipid = -1;\n\t\tvar pids = Object.keys(Setup);\n\t\tif (refresh) {\n\t\t\trefreshSystem(setup);\n\t\t} else {\n\t\t\tsetup();\n\t\t}\n\n\t\tfunction setup() {\n\t\t\tipid++;\n\t\t\tif (ipid >= pids.length) {\n\t\t\t\tpids = Object.keys(Start);\n\t\t\t\tipid = -1;\n\t\t\t\tstart();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar pid = pids[ipid];\n\t\t\tvar com = {};\n\t\t\tcom.Cmd = Setup[pid];\n\t\t\tcom.Passport = {};\n\t\t\tcom.Passport.To = pids[ipid];\n\t\t\tcom.Passport.Pid = genPid();\n\t\t\tsendMessage(com, setup);\n\t\t}\n\n\t\t// Start\n\t\tfunction start() {\n\t\t\tipid++;\n\t\t\tif (ipid >= pids.length) {\n\t\t\t\tRun();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar pid = pids[ipid];\n\t\t\tvar com = {};\n\t\t\tcom.Cmd = Start[pid];\n\t\t\tcom.Passport = {};\n\t\t\tcom.Passport.To = pids[ipid];\n\t\t\tcom.Passport.Pid = genPid();\n\t\t\tsendMessage(com, start);\n\t\t}\n\t}\n\n})();\n",
  "package.json": "{\n\t\"name\" : \"Nexus\",\n\t\"version\" : \"0.0.3\",\n\t\"dependencies\" : {\n\t\t\"async\" : \"~0.9.0\",\n\t\t\"node-uuid\" : \"~1.4.2\"\n\t}\n}",
  "ModName": "xCraft2.Nexus.Nexus"
}