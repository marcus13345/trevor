{
  "Nexus.js": "//Load the required modules\r\n(function() {\r\n\tvar fs = require('fs');\r\n\tvar Path = require('path');\r\n\tlet log= fs.createWriteStream(process.cwd()+\"/EventLog.txt\");\r\n\r\n\tvar Uuid;\r\n\tvar CacheDir;\r\n\tvar WorkDir = process.cwd();\r\n\tvar Config = {};\r\n\tvar Apex = {};\t\t// {<Name>: <pid of Apex>}\r\n\tvar Modules = {};\t// {<Name>: <mod desc>} - only in Genesis\r\n\tvar ModCache = {};\t// {<folder>: <module>}\r\n\tvar ApexIndex = {}; // {<Apex pid>:<folder>}\r\n\tvar EntCache = {};\t// {<Entity pid>:<Entity>\r\n\tvar ImpCache = {};\t// {<Implementation path>: <Implementation(e.g. disp)>}\r\n\tvar package = {};\r\n\tvar Mod = {};\r\n\tvar Nxs = {\r\n\t\tEventLog:EventLog,\r\n\t\tgenPid: genPid,\r\n\t\tgenPath: genPath,\r\n\t\tGetModule,\r\n\t\tgenModule: genModule,\r\n\t\tgenEntity: genEntity,\r\n\t\tdeleteEntity: deleteEntity,\r\n\t\tgetParameter: getParameter,\r\n\t\tgetFile,\r\n\t\tsendMessage: sendMessage\r\n\t}\r\n\tEventLog('=================================================');\r\n\r\n\t// Process input arguments and define macro parameters\r\n\tvar args = process.argv;\r\n\tlet arg;\r\n\tlet parts;\r\n\tlet Params = {};\r\n\tfor (var iarg = 0; iarg < args.length; iarg++) {\r\n\t\targ = args[iarg];\r\n\t\tEventLog(arg);\r\n\t\tparts = arg.split('=');\r\n\t\tif (parts.length == 2) {\r\n\t\t\tParams[parts[0]] = parts[1];\r\n\t\t}\r\n\t}\r\n\tvar config = 'config.json';\r\n\tif('Config' in Params)\r\n\t\tconfig = Params.Config;\r\n\tlet str = fs.readFileSync(config);\r\n\tlet val;\r\n\tif (str) {\r\n\t\tvar ini = JSON.parse(str);\r\n\t\tfor (key in ini) {\r\n\t\t\tval = ini[key];\r\n\t\t\tif (typeof val == 'string') {\r\n\t\t\t\tConfig[key] = Macro(val);\r\n\t\t\t\tParams[key] = Config[key];\r\n\t\t\t} else {\r\n\t\t\t\tConfig[key] = val;\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tEventLog(' ** No configuration file provided');\r\n\t\tprocess.exit(1);\r\n\t}\r\n\tEventLog(JSON.stringify(Config, null, 2));\r\n\r\n\tCacheDir = 'cache';\r\n\tif('Cache' in Params)\r\n\t\tCacheDir = Params.Cache;\r\n//\tremDir(CacheDir); // REMOVE REMOVE REMOVE REMOVE REMOVE REMOVE REMOVE\r\n\tif(!fs.existsSync(CacheDir)) {\r\n\t\tGenesis(Initiate);\r\n\t} else {\r\n\t\tInitiate(Run);\r\n\t}\r\n\r\n\tfunction EventLog(string){\r\n\t\t//event log only built to handle strings\r\n\t\t//write them out\r\n\t\tlog.write(string+\"\\n\");\r\n\t\t//currently we also write it to the console,this will not always exist\r\n\t\tconsole.log(string);\r\n\t}\r\n\r\n\t//-----------------------------------------------------Run\r\n\tfunction Run() {\r\n\t\tEventLog('\\n--Nexus/Run');\r\n\t\tif ('send' in process) {\r\n\t\t\tprocess.send('{\"Cmd\":\"Finished\"}');\r\n\t\t}\r\n\t}\r\n\r\n\t//-----------------------------------------------------remDir\r\n\t// Shake well before using\r\n\t// Recursive directory deletion\r\n\tfunction remDir(path) {\r\n\t\tvar files = [];\r\n\t\tif( fs.existsSync(path) ) {\r\n\t\t\tfiles = fs.readdirSync(path);\r\n\t\t\tfiles.forEach(function(file,index){\r\n\t\t\t\tvar curPath = path + \"/\" + file;\r\n\t\t\t\tif(fs.lstatSync(curPath).isDirectory()) { // recurse\r\n\t\t\t\t\tconsole.log('Deleting folder:' + curPath);\r\n\t\t\t\t\tremDir(curPath);\r\n\t\t\t\t} else { // delete file\r\n\t\t\t\t\tconsole.log('Deleting file:' + curPath);\r\n\t\t\t\t\tfs.unlinkSync(curPath);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tconsole.log('Deleting folder:' + path);\r\n\t\t\tfs.rmdirSync(path);\r\n\t\t}\r\n\t}\r\n\t//---------------------------------------------------------genPid\r\n\t// Create a new PID\r\n\tfunction genPid() {\r\n\t\tif(!Uuid)\r\n\t\t\tUuid = require('node-uuid');\r\n\t\tvar str = Uuid.v4();\r\n\t\tvar pid = str.replace(/-/g, '').toUpperCase();\r\n\r\n\t\treturn pid;\r\n\t}\r\n\r\n\t//---------------------------------------------------------genPath\r\n\tfunction genPath(filein) {\r\n\t\t//\tEventLog('!!genPath', filein);\r\n\t\tif(!filein) {\r\n\t\t\tEventLog(' ** ERR:Invalid file name');\r\n\t\t\treturn '';\r\n\t\t}\r\n\t\tvar cfg = Config;\r\n\t\tvar path;\r\n\t\tvar parts;\r\n\t\tvar file = filein;\r\n\t\tif(Config.Redirect) {\r\n\t\t\tif(file in Config.Redirect)\r\n\t\t\t\tfile = Config.Redirect[file];\r\n\t\t}\r\n\t\tif (file.charAt(0) == '/')\r\n\t\t\treturn file;\r\n\t\tif (file.charAt(0) == '{') { // Macro\r\n\t\t\tparts = file.split('}');\r\n\t\t\tif (parts.length != 2) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar name = parts[0].substr(1);\r\n\t\t\tif (name in cfg) {\r\n\t\t\t\tpath = cfg[name] + '/' + parts[1];\r\n\t\t\t\treturn path;\r\n\t\t\t} else {\r\n\t\t\t\tEventLog(' ** ERR:File <' + file + '> {' + name + '} not found');\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t\tparts = file.split(':');\r\n\t\tif (parts.length == 2) {\r\n\t\t\tif (parts[0] in cfg) {\r\n\t\t\t\tpath = cfg[parts[0]] + '/' + parts[1];\r\n\t\t\t} else {\r\n\t\t\t\tEventLog(' ** ERR:File <' + file + '> prefix not defined');\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tpath = file;\r\n\t\t}\r\n\t\treturn path;\r\n\t}\r\n\r\n\tfunction Macro(str) {\r\n\t\tlet state = 1;\r\n\t\tlet chr;\r\n\t\tlet s = '';\r\n\t\tlet param;\r\n\t\tfor (let i = 0; i < str.length; i++) {\r\n\t\t\tchr = str.charAt(i);\r\n\t\t\tswitch (state) {\r\n\t\t\t\tcase 1:\r\n\t\t\t\t\tif (chr == '{') {\r\n\t\t\t\t\t\tparam = '';\r\n\t\t\t\t\t\tstate = 2;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ts += chr;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase 2:\r\n\t\t\t\t\tif (chr == '}') {\r\n\t\t\t\t\t\tif (param in Params)\r\n\t\t\t\t\t\t\ts += Params[param];\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tthrow 'Parameter <' + param + '> not defined';\r\n\t\t\t\t\t\tstate = 1;\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tparam += chr;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (state != 1)\r\n\t\t\tthrow 'Curley brackets not matched in __Macro';\r\n\t\treturn s;\r\n\t}\r\n\r\n\t//-----------------------------------------------------send\r\n\t// Send message to an entity in the current systems (bag)\r\n\t// If call back provided, return to sender\r\n\tfunction sendMessage(com, fun) {\r\n\t\tconsole.log('--sendMessage', com.Cmd);\r\n\t\tif (!('Passport' in com)) {\r\n\t\t\tEventLog(' ** ERR:Message has no Passport, ignored');\r\n\t\t\tEventLog('    ' + JSON.stringify(com));\r\n\t\t\tif (fun)\r\n\t\t\t\tfun('No Passport');\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (!('To' in com.Passport) || !com.Passport.To) {\r\n\t\t\tEventLog(' ** ERR:Message has no destination entity, ignored');\r\n\t\t\tEventLog('    ' + JSON.stringify(com));\r\n\t\t\tconsole.trace();\r\n\t\t\tif(fun)\r\n\t\t\t\tfun('No recipient in message', com);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (!('Pid' in com.Passport)) {\r\n\t\t\tEventLog(' ** ERR:Message has no message id, ignored');\r\n\t\t\tEventLog('    ' + JSON.stringify(com));\r\n\t\t\tif(fun)\r\n\t\t\t\tfun('No message id', com);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t//var to = com.Passport.To;\r\n\t\tvar pid = com.Passport.To;\r\n\t\tif(pid in EntCache) {\r\n\t\t\tvar ent = EntCache[pid];\r\n\t\t\tent.dispatch(com, reply);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif(pid in ApexIndex) {\r\n\t\t\tconsole.log('In ApexIndex');\r\n\t\t\tgetEntity(pid, pid, done);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar apx;\r\n\t\tif('Apex' in com.Passport)\r\n\t\t\tapx = com.Passport.Apex;\r\n\t\telse\r\n\t\t\tapx = pid;\r\n\t\tgetEntity(apx, pid, done);\r\n\r\n\t\tfunction done(err, ent) {\r\n\t\t\tif (err) {\r\n\t\t\t\tEventLog(' ** ERR:' + err);\r\n\t\t\t\tconsole.log(JSON.stringify(com, null, 2));\r\n\t\t\t\tif (fun)\r\n\t\t\t\t\tfun(err, com);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tent.dispatch(com, reply);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tfunction reply(err, q) {\r\n\t\t\t//\tEventLog('..Nexus/send/reply', com.Cmd, com.Passport);\r\n\t\t\tif(fun)\r\n\t\t\t\tfun(err, q);\r\n\t\t}\r\n\t}\r\n\r\n\t//-----------------------------------------------------getParameter\r\n\t// Retrieve command line parameter\r\n\tfunction getParameter(name) {\r\n\t\tEventLog('--Nexus/GetParameter');\r\n\t\tEventLog('Params', JSON.stringify(Params, null, 2));\r\n\t\tif(name in Params)\r\n\t\t\treturn Params[name];\r\n\t}\r\n\r\n\t//-----------------------------------------------------Entity\r\n\t// This is the entity base class that is used to create\r\n\t// new entities.\r\n\tfunction Entity(nxs, imp, par) {\r\n\t\tvar Par = par;\r\n\t\tvar Imp = imp;\r\n\t\tvar Vlt = {};\r\n\r\n\t\treturn {\r\n\t\t\tPar: Par,\r\n\t\t\tVlt: Vlt,\r\n\t\t\tdispatch: dispatch,\r\n\t\t\tgenModule: genModule,\r\n\t\t\tgetModule,\r\n\t\t\tgenEntity:genEntity,\r\n\t\t\tdeleteEntity: deleteEntity,\r\n\t\t\tgenPid:genPid,\r\n\t\t\tgenPath:genPath,\r\n\t\t\tsend: send,\r\n\t\t\tsave: save,\r\n\t\t\tgetPid: getPid,\r\n\t\t\tgetFile,\r\n\t\t\tlog: log\r\n\t\t};\r\n\r\n\t\t//log data to EventLog.txt in the current working directory\r\n\t\t//this log only works with a single string \r\n\t\tfunction log(string){\r\n\t\t\t//we will write to the eventlog if this.log was misused\r\n\t\t\tif (arguments.length>1){\r\n\t\t\t\tnxs.EventLog(\"Error: Message may be incomplete\\n\"+\r\n\t\t\t\t\t\"more than one argument was passed to this.log()\");\r\n\t\t\t}\r\n\t\t\tnxs.EventLog(string);\r\n\t\t}\r\n\r\n\t\tfunction getFile(filename, fun){\r\n\t\t\tEventLog(`Getting file ${filename} from ${Par.Module}`);\r\n\t\t\tnxs.getFile(Par.Module, filename, fun);\r\n\t\t}\r\n\r\n\t\tfunction getModule(modulename,fun){\r\n\t\t\tEventLog(`Getting module ${modulename}`);\r\n\t\t\tnxs.GetModule(modulename,fun);\r\n\t\t}\r\n\r\n\t\t//-------------------------------------------------dispatch\r\n\t\t// Used by Nexus to dispatch messages\r\n\t\tfunction dispatch(com, fun) {\r\n\t\t\t//\tEventLog(Mod);\r\n\t\t\t//  EventLog('||dispatch', com.Cmd);\r\n\t\t\tvar disp = Imp.dispatch;\r\n\t\t\tif (com.Cmd in disp) {\r\n\t\t\t\tdisp[com.Cmd].call(this, com, fun);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif('*' in disp) {\r\n\t\t\t\tdisp['*'].call(this, com, fun);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tEventLog(' ** ERR:Nada Cmd:' + com.Cmd);\r\n\t\t\tfun('Nada', com);\r\n\t\t}\r\n\r\n\t\t//-------------------------------------------------genModule\r\n\t\t// Generate module and return (err, pidapx);\r\n\t\tfunction genModule(mod, fun) {\r\n\t\t//\tEventLog('--Entity/genModule');\r\n\t\t\tnxs.genModule(mod, fun);\r\n\t\t}\r\n\r\n\r\n\t\tfunction deleteEntity(fun){\r\n\t\t\t//EventLog(\"DElElTingASDF\")\r\n\t\t\tnxs.deleteEntity(Par.Pid,fun);\r\n\t\t}\r\n\r\n\t\tfunction genEntity(par,fun){\r\n\t\t\tnxs.genEntity(par, fun);\r\n\t\t}\r\n\r\n\t\tfunction genPid(){\r\n\t\t\treturn nxs.genPid();\r\n\t\t}\r\n\r\n\t\tfunction genPath(mod){\r\n\t\t\treturn nxs.genPath(mod);\r\n\t\t}\r\n\r\n\t\t//-------------------------------------------------send\r\n\t\t// Send message to another entity which can be in another\r\n\t\t// bag or browser. Callback when message is returned\r\n\t\tfunction send(com, pid, fun) {\r\n\t\t\tif(!('Passport' in com))\r\n\t\t\t\tcom.Passport = {};\r\n\t\t\tcom.Passport.To = pid;\r\n\t\t\tif('Apex' in Par)\r\n\t\t\t\tcom.Passport.Apex = Par.Apex;\r\n\t\t\tif (fun)\r\n\t\t\t\tcom.Passport.From = Par.Pid;\r\n\t\t\tif (!(\"Pid\" in com.Passport))\r\n\t\t\t\tcom.Passport.Pid = genPid();\r\n\t\t\tnxs.sendMessage(com, fun);\r\n\t\t}\r\n\r\n\t\t//-------------------------------------------------save\r\n\t\t// Save entity in Cache\r\n\t\tfunction save(fun) {\r\n\t\t\tconsole.log('--Nexus/save');\r\n\t\t\tvar path = CacheDir + '/';\r\n\t\t\tpath += Par.Module + '/';\r\n\t\t\tpath += Par.Apex + '/';\r\n\t\t\tpath += Par.Pid + '.json';\r\n\t\t\tvar str = JSON.stringify(Par, null, 2);\r\n\t\t\tconsole.log(str);\r\n\t\t\tfs.writeFile(path, str, done);\r\n\r\n\t\t\tfunction done(err) {\r\n\t\t\t\tif (fun)\r\n\t\t\t\t\tfun(err);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t//-------------------------------------------------getPid\r\n\t\t// Return Pid of entity\r\n\t\tfunction getPid() {\r\n\t\t\treturn Par.Pid;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//-----------------------------------------------------genEntity\r\n\t// Create entity from parameter object in current module\r\n\tfunction genEntity(par, fun) {\r\n\t\tEventLog(' ** ERR:genEntity not implemented');\r\n\t\tfun('genEntity not implmeneted');\r\n\t}\r\n\r\n\tfunction deleteEntity(pid, fun){\r\n\t\tEventLog(' ** ERR:deleteEntity not implemented');\r\n\t\tfun('deleteEntity not implmeneted');\r\n\t}\r\n\r\n\tfunction getFile(module, filename, fun){\r\n\t\tlet mod = ModCache[module];\r\n\t\t//console.log(Object.keys(ModCache[module]));\r\n\t\tif (filename in mod){\r\n\t\t\tfun(null,mod[filename])\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tlet err = `Error: File ${filename} does not exist in module ${module}`;\r\n\t\tEventLog(err);\r\n\t\tfun(err);\r\n\t}\r\n\r\n\t//-----------------------------------------------------getEntity\r\n\tfunction getEntity(apx, pid, fun) {\r\n\t\tvar imp;\r\n\t\tvar par;\r\n\t\tvar ent;\r\n\r\n\t\t// If entity already cached, just return it\r\n\t\tif (pid in EntCache) {\r\n\t\t\tent = EntCache[pid];\r\n\t\t\tfun(null, ent);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Check to see if Apex entity in this system\r\n\t\tif(!(apx in ApexIndex)) {\r\n\t\t\t//\tEventLog(' ** ERR:Pid <' + pid + '> not Apex in system');\r\n\t\t\tfun('Not available');\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar folder = ApexIndex[apx];\r\n\t\tvar path = CacheDir + '/' + folder + '/' + apx + '/' + pid + '.json';\r\n\t\tfs.readFile(path, function(err, data) {\r\n\t\t\tif(err) {\r\n\t\t\t\tconsole.log(' ** ERR:<' + path + '> unavailable');\r\n\t\t\t\tif(fun)\r\n\t\t\t\t\tfun('Unavailable');\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar par = JSON.parse(data.toString());\r\n\t\t\tvar impkey = folder + '/' + par.Entity;\r\n\t\t\tif(impkey in ImpCache) {\r\n\t\t\t\tvar imp = ImpCache[impkey];\r\n\t\t\t\tvar ent = new Entity(Nxs, imp, par);\r\n\t\t\t\tEntCache[pid] = ent;\r\n\t\t\t\tfun(null, ent);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tGetModule(folder, function(err, mod) {\r\n\t\t\t\tif (err) {\r\n\t\t\t\t\tconsole.log(' ** ERR:Module <' + folder + '> not available');\r\n\t\t\t\t\tif (fun)\r\n\t\t\t\t\t\tfun('Module not available');\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif(!(par.Entity in mod)) {\r\n\t\t\t\t\tconsole.log(' ** ERR:<' + par.Entity + '> not in module <' + folder + '>');\r\n\t\t\t\t\tif(fun)\r\n\t\t\t\t\t\tfun('Null entity');\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tvar imp = eval(mod[par.Entity]);\r\n\t\t\t\tImpCache[impkey] = imp;\r\n\t\t\t\tvar ent = new Entity(Nxs, imp, par);\r\n\t\t\t\tEntCache[pid] = ent;\r\n\t\t\t\tfun(null, ent);\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\t//-------------------------------------------------genModule\r\n\t// This is the version used to install modules\r\n\t// after startup, such as web dashboards and such.\r\n\t// It provides for safe setup and start which is\r\n\t// handled by Nxs for modules instantiated initially.\r\n\t// TBD: If modules saved, Initializers will need to be\r\n\t//      added to the Start and Setup lists in Root\r\n\tfunction genModule(inst, fun) {\r\n\t\tvar that = this;\r\n\t\tvar modnam = inst.Module;\r\n\t\tGetModule(modnam, function(err, mod) {\r\n\t\t\tif(err) {\r\n\t\t\t\tconsole.log(' ** ERR:GenModule err -', err);\r\n\t\t\t\tif(fun)\r\n\t\t\t\t\tfun(err);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar pidapx = genPid();\r\n\t\t\tvar ents = compileInstance(pidapx, inst);\r\n\t\t\tents.forEach(function(par) {\r\n\t\t\t\tlet impkey = modnam + par.Entity;\r\n\t\t\t\tvar imp;\r\n\t\t\t\tif(impkey in ImpCache) {\r\n\t\t\t\t\timp = ImpCache[impkey];\r\n\t\t\t\t} else {\r\n\t\t\t\t\timp = eval(mod[par.Entity]);\r\n\t\t\t\t\tImpCache[impkey] = imp;\r\n\t\t\t\t}\r\n\t\t\t\tvar ent = new Entity(Nxs, imp, par);\r\n\t\t\t\tEntCache[par.Pid] = ent;\r\n\t\t\t});\r\n\t\t\tif(fun) {\r\n\t\t\t\tfun(null, pidapx);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t//-----------------------------------------------------Genesis\r\n\t// Create cache if it does nto exist and populate\r\n\t// This is called only once when a new systems is\r\n\t// first instantiated\r\n\tfunction Genesis(fun) {\r\n\t\tEventLog('--Nexus/Genesis');\r\n\t\tvar Folders = [];\r\n\r\n\t\t// Create new cache and install high level\r\n\t\t// module subdirectories. Each of these also\r\n\t\t// has a link to the source of that module,\r\n\t\t// at this point a local file directory, but\r\n\t\t// eventually this should be some kind of\r\n\t\t// alternate repository (TBD)\r\n\t\tvar keys = Object.keys(Config.Modules);\r\n\t\tfor (let i = 0; i < keys.length; i++) {\r\n\t\t\tlet key = keys[i];\r\n\t\t\tif(key == 'Deferred') {\r\n\t\t\t\tvar arr = Config.Modules[key];\r\n\t\t\t\tarr.forEach(function(folder) {\r\n\t\t\t\t\tif(Folders.indexOf(folder) < 0)\r\n\t\t\t\t\t\tFolders.push(folder);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tvar mod = {};\r\n\t\t\t\tconsole.log('mod', mod);\r\n\t\t\t\tlet folder = Config.Modules[key].Module.replace(/\\//g, '.').replace(/:/g, '.');\r\n\t\t\t\tif(Folders.indexOf(folder) < 0)\r\n\t\t\t\t\tFolders.push(folder);\r\n\t\t\t}\r\n\t\t}\r\n\t\tconsole.log('Folders', Folders);\r\n\t\tlet nfolders = Folders.length;\r\n\t\tlet ifolder = -1;\r\n\t\tnext();\r\n\r\n\t\tfunction next() {\r\n\t\t\tifolder++;\r\n\t\t\tif(ifolder >= nfolders) {\r\n\t\t\t\trefreshSystem(populate);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tlet folder = Folders[ifolder];\r\n\t\t\tGetModule(folder, function(err, mod) {\r\n\t\t\t\tModCache[folder] = mod;\r\n\t\t\t\tnext();\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tfunction populate() {\r\n\t\t\tconsole.log('--populate');\r\n\t\t\t// Build cache structure and Module.json\r\n\t\t\tfs.mkdirSync(CacheDir);\r\n\t\t\tfor(let folder in ModCache) {\r\n\t\t\t\tconsole.log(folder);\r\n\t\t\t\tvar mod = ModCache[folder];\r\n\t\t\t\tif('schema.json' in mod) {\r\n\t\t\t\t\tvar schema = JSON.parse(mod['schema.json']);\r\n\t\t\t\t\tconsole.log('schema', JSON.stringify(schema, null, 2));\r\n\t\t\t\t\tif('Apex' in schema) {\r\n\t\t\t\t\t\tvar apx = schema.Apex;\r\n\t\t\t\t\t\tif('$Setup' in apx)\r\n\t\t\t\t\t\t\tmod.Setup = apx['$Setup'];\r\n\t\t\t\t\t\tif('$Start' in apx)\r\n\t\t\t\t\t\t\tmod.Start = apx['$Start'];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tvar dir = CacheDir + '/' + folder;\r\n\t\t\t\tfs.mkdirSync(dir);\r\n\t\t\t\tpath = dir + '/Module.json';\r\n\t\t\t\tvar str = JSON.stringify(ModCache[folder]);\r\n\t\t\t\tfs.writeFileSync(path, str);\r\n\t\t\t\tvar path = dir + '/Module.json';\r\n\t\t\t\tfs.writeFileSync(path, JSON.stringify(mod, null, 2));\r\n\t\t\t\tconsole.log(Object.keys(mod));\r\n\t\t\t}\r\n\r\n\t\t\t// Assign pids to all instance in Configu.Modules\r\n\t\t\tfor(let instname in Config.Modules)\r\n\t\t\t\tApex[instname] = genPid();\r\n\t\t\tconsole.log('Apex', Apex);\r\n\r\n\t\t\t// Now populate all of the modules from config.json\r\n\t\t\tfor(let instname in Config.Modules) {\r\n\t\t\t\tif(instname === 'Deferred')\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tif(instname === 'Nexus')\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tvar inst = Config.Modules[instname];\r\n\t\t\t\tconsole.log(instname, inst);\r\n\t\t\t\tvar pidinst = Apex[instname];\r\n\t\t\t\tvar ents = compileInstance(pidinst, inst);\r\n\t\t\t\tfolder = inst.Module;\r\n\t\t\t\t// The following is for backword compatibility only\r\n\t\t\t\tvar folder = folder.replace(/\\:/, '.').replace(/\\//g, '.');\r\n\t\t\t\tvar dirinst = CacheDir + '/' + folder + '/' + pidinst;\r\n\t\t\t\tfs.mkdirSync(dirinst);\r\n\t\t\t\tents.forEach(function(ent) {\r\n\t\t\t\t\tlet path = dirinst + '/' + ent.Pid + '.json';\r\n\t\t\t\t\tconsole.log('entity path', path);\r\n\t\t\t\t\tconsole.log('ent', ent);\r\n\t\t\t\t\tfs.writeFileSync(path, JSON.stringify(ent, null, 2));\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t//\tprocess.exit(0);\r\n\t\t\tInitiate(Run);\r\n\t\t}\r\n\t}\r\n\r\n\t//----------------------------------------------------=CompileMOdule\r\n\t// Generate array of entities from module\r\n\t// Module must be in cache to allow use by both Genesis and\r\n\t// GenModule\r\n\t// The first parameter is the pid assigned to the Apex\r\n\tfunction compileInstance(pidapx, inst) {\r\n\t\tvar Local = {};\r\n\t\tvar modnam = inst.Module;\r\n\t\tvar mod;\r\n\t\tvar ents = [];\r\n\t\t// The following is for backword compatibility only\r\n\t\tvar modnam = modnam.replace(/\\:/, '.').replace(/\\//g, '.');\r\n\t\tif(modnam in ModCache) {\r\n\t\t\tmod = ModCache[modnam];\r\n\t\t} else {\r\n\t\t\tconsole.log(' ** ERR:' + 'Module <' + modnam + '> not in ModCache');\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar schema = JSON.parse(mod['schema.json']);\r\n\t\tvar entkeys = Object.keys(schema);\r\n\t\tconsole.log('entkeys', entkeys);\r\n\t\tLocal = {};\r\n\t\tfor(j=0; j<entkeys.length; j++) {\r\n\t\t\tlet entkey = entkeys[j];\r\n\t\t\tif(entkey === 'Apex')\r\n\t\t\t\tLocal[entkey] = pidapx;\r\n\t\t\telse\r\n\t\t\t\tLocal[entkey] = genPid();\r\n\t\t}\r\n\t\tconsole.log('Local', Local);\r\n\t\tfor(j=0; j<entkeys.length; j++) {\r\n\t\t\tlet entkey = entkeys[j];\r\n\t\t\tlet ent = schema[entkey];\r\n\t\t\tent.Pid = Local[entkey];\r\n\t\t\tif(entkey == 'Apex' && 'Par' in inst) {\r\n\t\t\t\tvar pars = Object.keys(inst.Par);\r\n\t\t\t\tfor(var ipar=0; ipar<pars.length; ipar++) {\r\n\t\t\t\t\tvar par = pars[ipar];\r\n\t\t\t\t\tent[par] = inst.Par[par];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tent.Module = modnam;\r\n\t\t\tent.Apex = pidapx;\r\n\t\t\tvar pars = Object.keys(ent);\r\n\t\t\tfor(ipar=0; ipar<pars.length; ipar++) {\r\n\t\t\t\tvar par = pars[ipar];\r\n\t\t\t\tvar val = ent[par];\r\n\t\t\t\tswitch(typeof val) {\r\n\t\t\t\t\tcase 'string':\r\n\t\t\t\t\t\tent[par] = symbol(val);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'object':\r\n\t\t\t\t\t\tif(Array.isArray(val)) {\r\n\t\t\t\t\t\t\tfor(var ival=0; ival.val.length; ival++)\r\n\t\t\t\t\t\t\t\tval[ival] = symbol(val[ival]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tents.push(ent);\r\n\t\t}\r\n\t\treturn ents;\r\n\r\n\t\tfunction symbol(val) {\r\n\t\t\tvar sym = val.substr(1);\r\n\t\t\tif(val.charAt(0) === '$' && sym in Apex)\r\n\t\t\t\treturn Apex[sym];\r\n\t\t\tif(val.charAt(0) === '#' && sym in Local)\r\n\t\t\t\treturn Local[sym];\r\n\t\t\treturn val;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction refreshSystem(func) {\r\n\t\t// Clean up all of the files from the\r\n\t\t// previous refresh. This is most important\r\n\t\t// for the package.json and node_modeuls dir\r\n\t\tconsole.log('--refreshSystems');\r\n\t\tvar files = fs.readdirSync(WorkDir);\r\n\t\tfor (let i = 0; i < files.length; i++) {\r\n\t\t\tlet file = files[i];\r\n\t\t\tvar path = WorkDir + '/' + file;\r\n\t\t\tswitch (file) {\r\n\t\t\t\tcase 'cache':\r\n\t\t\t\tcase 'config.json':\r\n\t\t\t\tcase 'browser.json':\r\n\t\t\t\t\t//\tconsole.log('Keeping:' + path);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (fs.lstatSync(path).isDirectory()) { // recurse\r\n\t\t\t\t// remDir(path);\r\n\t\t\t\t//\tdeleteFolderRecursive(curPath);\r\n\t\t\t} else { // delete file\r\n\t\t\t\t//\tconsole.log('Deleting file:' + path);\r\n\t\t\t\t//\tfs.unlinkSync(path);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Reconstruct package.json and nod_modules\r\n\t\t// directory by merging package.json of the\r\n\t\t// individual modules and then running npm\r\n\t\t// to create node_modules directory for system\r\n\t\tvar package;\r\n\t\t//console.log('ModeCache', ModCache);\r\n\t\tfor(let folder in ModCache) {\r\n\t\t\tlet mod = ModCache[folder];\r\n\t\t\tif('package.json' in mod) {\r\n\t\t\t\tobj = JSON.parse(mod['package.json']);\r\n\t\t\t\tconsole.log('Input', obj);\r\n\t\t\t\tif(!package) {\r\n\t\t\t\t\tpackage = obj;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\t//console.log('A');\r\n\t\t\t\tif (obj.dependencies) {\r\n\t\t\t\t\t//console.log('B');\r\n\t\t\t\t\tif (!package.dependencies) package.dependencies = {};\r\n\t\t\t\t\tfor (key in obj.dependencies) {\r\n\t\t\t\t\t\tconsole.log('key', key);\r\n\t\t\t\t\t\tif (!(key in package.dependencies))\r\n\t\t\t\t\t\t\tpackage.dependencies[key] = obj.dependencies[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (obj.devDependencies) {\r\n\t\t\t\t\tif (!package.devDependencies) package.devDependencies = {};\r\n\t\t\t\t\tfor (key in obj.devDependencies) {\r\n\t\t\t\t\t\tif (!(key in package.devDependencies))\r\n\t\t\t\t\t\t\tpackage.devDependencies[key] = obj.devDependencies[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tconsole.log('output', package);\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar strout = JSON.stringify(package, null, 2);\r\n\t\tfs.writeFileSync('package.json', strout);\r\n\t\tconst proc = require('child_process');\r\n\t\tvar npm = (process.platform === \"win32\" ? \"npm.cmd\" : \"npm\");\r\n\t\tvar ps = proc.spawn(npm, ['install']);\r\n\r\n\t\tps.on('err', function(err) {\r\n\t\t\tEventLog('Failed to start child process.');\r\n\t\t\tEventLog('err:' + err);\r\n\t\t});\r\n\r\n\t\tps.on('exit', function(code) {\r\n\t\t\tEventLog('npm process exited with code:' + code);\r\n\t\t\tEventLog('Current working directory: ' + process.cwd());\r\n\t\t\tfunc();\r\n\t\t});\r\n\t}\r\n\r\n\t//-----------------------------------------------------GetModule\r\n\t// This is a surrogate for an eventual Module Server. This\r\n\t// code should be useful in developing such.\r\n\t// Because Nexus during Genesis does not have zip capability,\r\n\t// it relies on the Module Server to deliver content in that form.\r\n\t// Module Server names use dot notiation as in domain.family.module\r\n\t// where..\r\n\t//    domain is a major domain name such as 'xCraft2\", or 'xGraph'\r\n\t//    family is a grouping withing the domain such as 'Widgets'\r\n\t//    module is the name withing that group which can be further\r\n\t//        separated by dots as desired\r\n\tfunction GetModule(modnam, fun) {\r\n\t\tconsole.log('##GetModule', modnam);\r\n\t\tvar ModName = modnam.replace(/\\:/, '.').replace(/\\//g, '.');\r\n\t\tvar dir = ModName.replace('.', ':').replace(/\\./g, '/');\r\n\t\tvar ModPath = genPath(dir);\r\n\t\tif(ModName in ModCache) {\r\n\t\t\tfun(null, ModCache[ModName]);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvar mod = {};\r\n\t\tfs.readdir(ModPath, function(err, files) {\r\n\t\t\tif(err) {\r\n\t\t\t\tconsole.log(' ** ERR:Module <' + ModPath + '? not available');\r\n\t\t\t\tfun(err);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar nfile = files.length;\r\n\t\t\tvar ifile = -1;\r\n\t\t\tscan();\r\n\r\n\t\t\tfunction scan() {\r\n\t\t\t\tifile++;\r\n\t\t\t\tif(ifile >= nfile) {\r\n\t\t\t\t\tmod.ModName = ModName;\r\n\t\t\t\t\tModCache[ModName] = mod;\r\n\t\t\t\t\tfun(null, mod);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tvar file = files[ifile];\r\n\t\t\t\tvar path = ModPath + '/' + file;\r\n\t\t\t\tfs.lstat(path, function(err, stat) {\r\n\t\t\t\t\tif(stat) {\r\n\t\t\t\t\t\tif(!stat.isDirectory()) {\r\n\t\t\t\t\t\t\tfs.readFile(path, function(err, data) {\r\n\t\t\t\t\t\t\t\tif(err) {\r\n\t\t\t\t\t\t\t\t\tfun(err);\r\n\t\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tmod[file] = data.toString();\r\n\t\t\t\t\t\t\t\tscan();\r\n\t\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t\t});\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tscan();\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\t//-----------------------------------------------------Initialize\r\n\tfunction Initiate(fun) {\r\n\t\tEventLog('\\n--Nexus/Initiate');\r\n\t\tModules = {};\r\n\t\tApexIndex = {};\r\n\t\tvar Setup = {};\r\n\t\tvar Start = {};\r\n\t\tvar folders = fs.readdirSync(CacheDir);\r\n\t\tconsole.log('folders', folders);\r\n\t\tfor(var ifold=0; ifold<folders.length; ifold++) {\r\n\t\t\tvar folder = folders[ifold];\r\n\t\t\tvar dir = CacheDir + '/' + folder;\r\n\t\t\tif(!fs.lstatSync(dir).isDirectory())\r\n\t\t\t\tcontinue;\r\n\t\t\tvar path = dir + '/Module.json';\r\n\t\t\tif(!fs.existsSync(path))\r\n\t\t\t\tcontinue;\r\n\t\t\tvar data = fs.readFileSync(path).toString();\r\n\t\t\tvar mod = JSON.parse(data);\r\n\t\t\t//console.log('mod', JSON.stringify(mod, null, 2));\r\n\t\t\tModules[folder] = mod;\r\n\t\t\tvar files = fs.readdirSync(dir);\r\n\t\t\tfor(var ifile=0; ifile<files.length; ifile++) {\r\n\t\t\t\tvar file = files[ifile];\r\n\t\t\t\tif(file.length !== 32)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\tvar path = dir + '/' + file;\r\n\t\t\t\tif(fs.lstatSync(path).isDirectory()) {\r\n\t\t\t\t\tApexIndex[file] = folder;\r\n\t\t\t\t\tif('Setup' in mod)\r\n\t\t\t\t\t\tSetup[file] = mod.Setup;\r\n\t\t\t\t\tif('Start' in mod)\r\n\t\t\t\t\t\tStart[file] = mod.Start;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t//console.log('ApexIndex', ApexIndex);\r\n\t\t}\r\n\t\t//console.log('Modules', JSON.stringify(Modules, null, 2));\r\n\t\tconsole.log('ApexIndex', JSON.stringify(ApexIndex, null, 2));\r\n\t\tconsole.log('Setup', JSON.stringify(Setup, null, 2));\r\n\t\tconsole.log('Start', JSON.stringify(Start, null, 2));\r\n\r\n\t\t// Setup\r\n\t\tvar ipid = -1;\r\n\t\tvar pids = Object.keys(Setup);\r\n\t\tsetup();\r\n\r\n\t\tfunction setup() {\r\n\t\t\tipid++;\r\n\t\t\tif(ipid >= pids.length) {\r\n\t\t\t\tpids = Object.keys(Start);\r\n\t\t\t\tipid = -1;\r\n\t\t\t\tstart();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar pid = pids[ipid];\r\n\t\t\tvar com = {};\r\n\t\t\tcom.Cmd = Setup[pid];\r\n\t\t\tcom.Passport = {};\r\n\t\t\tcom.Passport.To = pids[ipid];\r\n\t\t\tcom.Passport.Pid = genPid();\r\n\t\t\tsendMessage(com, setup);\r\n\t\t}\r\n\r\n\t\t// Start\r\n\t\tfunction start() {\r\n\t\t\tipid++;\r\n\t\t\tif(ipid >= pids.length) {\r\n\t\t\t\tRun();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvar pid = pids[ipid];\r\n\t\t\tvar com = {};\r\n\t\t\tcom.Cmd = Start[pid];\r\n\t\t\tcom.Passport = {};\r\n\t\t\tcom.Passport.To = pids[ipid];\r\n\t\t\tcom.Passport.Pid = genPid();\r\n\t\t\tsendMessage(com, start);\r\n\t\t}\r\n\t}\r\n\r\n})();\r\n",
  "package.json": "{\r\n\t\"name\" : \"Nexus\",\r\n\t\"version\" : \"0.0.3\",\r\n\t\"dependencies\" : {\r\n\t\t\"async\" : \"~0.9.0\",\r\n\t\t\"node-uuid\" : \"~1.4.2\"\r\n\t}\r\n}",
  "ModName": "xCraft2.Nexus.Nexus"
}