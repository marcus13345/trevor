{
  "ViewBuilder.js": "//# sourceURL=ViewBuilder.js\n//jshint esversion: 6\n(function ViewBuilder() {\n\n\tclass ViewBuilder {\n\t\tSetup(com, fun) {\n\t\t\tconsole.log(\"ViewBuilder/Setup\");\n\t\t\tthis.Vlt.Nodes = {};\n\t\t\t/* \n\t\t\tNodes object will be structured as \n\t\t\t{\n\t\t\t\tPosition: [\n\t\t\t\t\tx,\n\t\t\t\t\ty,\n\t\t\t\t\tz\n\t\t\t\t],\n\t\t\t\tColor:\"stringColor\",\n\t\t\t\tConnections:[\n\t\t\t\t\t\"idOfConnectedNodes\"\n\t\t\t\t]\n\t\t\t}\n\t\t\t*/\n\t\t\tthis.Vlt.Directory = this.Par.Directory ||`${process.cwd()}/Data/`;\n\n\t\t\t//this.Vlt.xRange = [-5,5];\n\t\t\t//this.Vlt.yRange = [-5,5];\n\t\t\t\n\n\n\n\t\t\t//for the 3 layer grid wth gradient color by z axis\n\t\t\t//\n\t\t\t//\n\t\t\t// this.Vlt.zRange = [0, 3];\n\t\t\t// this.Vlt.Noise = [0.2,0.2,0.2];\n\t\t\t// this.Vlt.zStep = 1; //in minimum of single units\n\t\t\t// this.Vlt.xStep = 1; //in minimum of single units\n\t\t\t// this.Vlt.yStep = 1; //in minimum of single units\n\t\t\t// this.Vlt.xRadius = 5;\n\t\t\t// this.Vlt.zRadius = 3;\n\t\t\t// this.Vlt.yRadius = 5;\n\t\t\t// this.Vlt.probRange = [.3, 0];\n\t\t\t// this.Vlt.connRange = [.2, 0];\n\t\t\t//this.Vlt.gradientColor = true;\n\t\t\t\n\n\n\n\n\n\n\n\n\n\t\t\tthis.Vlt.zRange = [0, 2];\n\t\t\tthis.Vlt.Noise = [0.2,0.2,0.2];\n\t\t\tthis.Vlt.zStep = 1; //in minimum of single units\n\t\t\tthis.Vlt.xStep = 1; //in minimum of single units\n\t\t\tthis.Vlt.yStep = 1; //in minimum of single units\n\t\t\tthis.Vlt.xRadius = 2;\n\t\t\tthis.Vlt.zRadius = 2;\n\t\t\tthis.Vlt.yRadius = 2;\n\t\t\tthis.Vlt.probRange = [.3, .1];\n\t\t\tthis.Vlt.connRange = [.2, .2];\n\t\t\tthis.Vlt.gradientColor = false;\n\t\t\tthis.Vlt.colorSet = [[255,0,0],[0,255,0],[255,255,0],[255,0,255],[0,255,255]];\n\t\t\tthis.Vlt.colorScheme = (this.Vlt.GradientColor? ((x,y,z) =>{\n\t\t\t\tconsole.log([x,y,z], (1-((z-this.Vlt.zRange[0])/(this.Vlt.zRange[1]-this.Vlt.zRange[0])))*255);\n\t\t\t\tlet r = (Math.floor((1- ((z-this.Vlt.zRange[0])/(this.Vlt.zRange[1]-this.Vlt.zRange[0])))*255) << 16) & 0xFF0000;\n\t\t\t\tlet g = (Math.floor((z-this.Vlt.zRange[0])/(this.Vlt.zRange[1]-this.Vlt.zRange[0])*255) <<  8) & 0x00FF00;\n\t\t\t\tlet b = (0& 0x0000ff);//(Math.floor((z-this.Vlt.zRange[0])/(this.Vlt.zRange[1]-this.Vlt.zRange[0])*255)      ) & 0x0000FF;\n\t\t\t\t\n\t\t\t\treturn (r+g+b);\n\t\t\t}):((x,y,z)=>{\n\t\t\t\tlet rgb = this.Vlt.colorSet[Math.floor(Math.random()*this.Vlt.colorSet.length)];\n\t\t\t\treturn ((rgb[0]<<16&0xff0000)+(rgb[1]<<8&0xffff)+(rgb[2]&0xff));\n\t\t\t}));\n\n\t\t\tthis.send({Cmd:\"BuildNetwork\"}, this.Par.Pid);\n\n\t\t\tfun(null, com);\n\t\t}\n\n\t\tBuildNetwork(com, fun){\n\t\t\tconsole.log(\"ViewBuilder/BuildNetwork\");\n\t\t\t\n\t\t\tif (!(\"ConnData\" in this.Vlt))\n\t\t\t\tthis.Vlt.ConnData = {};\n\t\t\tif (!(\"Locs\" in this.Vlt))\n\t\t\t\tthis.Vlt.Locs = [];\n\t\t\tif (!(\"Levels\" in this.Vlt))\n\t\t\t\tthis.Vlt.Levels = {};\n\t\t\tif (!(\"Locs\" in this.Vlt))\n\t\t\t\tthis.Vlt.Locs = [];\n\n\t\t\t//discretize the populatable area\n\t\t\tfor (let z = Math.round(this.Vlt.zRange[0]); \n\t\t\t\tz <= this.Vlt.zRange[1]; \n\t\t\t\tz += Math.floor(this.Vlt.zStep)\n\t\t\t){\n\t\t\t\tfor (let x = Math.round(-1*Math.sqrt((this.Vlt.xRadius*this.Vlt.xRadius)*(1-(z*z)/(this.Vlt.zRadius*this.Vlt.zRadius)))); \n\t\t\t\t\tx <= Math.sqrt((this.Vlt.xRadius*this.Vlt.xRadius)*1-(z*z)/(this.Vlt.zRadius*this.Vlt.zRadius));\n\t\t\t\t\tx += Math.floor(this.Vlt.xStep)\n\t\t\t\t){\n\t\t\t\t\tfor (let y = Math.round(-1*Math.sqrt((this.Vlt.yRadius*this.Vlt.yRadius)*(1-(z*z)/(this.Vlt.zRadius*this.Vlt.zRadius)-(x*x)/(this.Vlt.xRadius*this.Vlt.xRadius))));\n\t\t\t\t\t\ty <= Math.sqrt((this.Vlt.yRadius*this.Vlt.yRadius)*(1-(z*z)/(this.Vlt.zRadius*this.Vlt.zRadius)-(x*x)/(this.Vlt.xRadius*this.Vlt.xRadius)));\n\t\t\t\t\t\ty += Math.floor(this.Vlt.yStep)\n\t\t\t\t\t){\n\t\t\t\t\t\t//console.log([x,y,z]);\n\t\t\t\t\t\tthis.Vlt.Locs.push([x,y,z]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tthis.Vlt.nodeCount = 0; \n\t\t\t//based on the heigh determine where nodes actually exist and push them to the Nodes array in this.Vlt\n\t\t\tfor (let i = 0; i<this.Vlt.Locs.length; i ++){\n\t\t\t\tlet location = this.Vlt.Locs[i];\n\t\t\t\tlet locProb = this.Vlt.probRange[0] + (this.Vlt.probRange[1]-this.Vlt.probRange[0])*((location[2]-this.Vlt.zRange[0])/(this.Vlt.zRange[1]-this.Vlt.zRange[0]));\n\t\t\t\t//console.log(location, locProb)\n\t\t\t\tif (Math.random()<(this.Vlt.probRange[0] + locProb)){\n\t\t\t\t\t//we will add this location\n\t\t\t\t\tthis.Vlt.nodeCount++;\n\n\t\t\t\t\tthis.Vlt.Nodes[i] = {\n\t\t\t\t\t\tPosition: location.map( (num,idx)=>{return (num+(Math.random()*2*this.Vlt.Noise[idx] - this.Vlt.Noise[idx]));}),\n\t\t\t\t\t\tColor: this.Vlt.colorScheme(...location),\n\t\t\t\t\t\tConnections:[]\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(location[2] in this.Vlt.Levels))\n\t\t\t\t\t\tthis.Vlt.Levels[[location[2]]] = [];\n\t\t\t\t\tthis.Vlt.Levels[location[2]].push(i);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconsole.log(\"There are \", this.Vlt.nodeCount, \" nodes\");\n \t\t\tconsole.log(\"Levels: \",this.Vlt.Levels);\n\n\n\t\t\t//determing the connection numbers between layers;\n\t\t\tlet connPercent,connNum;\n\t\t\tfor (let z in this.Vlt.Levels){\n\t\t\t\tif (! this.Vlt.Levels.hasOwnProperty(z))\n\t\t\t\t\tcontinue;\n\t\t\t\tconsole.log(\"z is \", z, ((z-1)<this.Vlt.zRange[0]?this.Vlt.zRange[0]:(z-1)));\n\t\t\t\tconnPercent =  this.Vlt.connRange[0] + (this.Vlt.connRange[1]-this.Vlt.connRange[0])*((z-this.Vlt.zRange[0])/(this.Vlt.zRange[1]-this.Vlt.zRange[0]));\n\t\t\t\tlet index = (((z-1)<this.Vlt.zRange[0]?this.Vlt.zRange[0]:(z-1)) in this.Vlt.Levels?((z-1)<this.Vlt.zRange[0]?this.Vlt.zRange[0]:(z-1)): (1+ ((z-1)<this.Vlt.zRange[0]?this.Vlt.zRange[0]:(z-1))));\n\t\t\t\tconnNum = (Math.floor(this.Vlt.Levels[index].length*connPercent)<1?1:(Math.floor(this.Vlt.Levels[index].length*connPercent)));\n\t\t\t\tthis.Vlt.ConnData[z] = {\n\t\t\t\t\tPercentBelow: connPercent,\n\t\t\t\t\tNumberBelow: connNum\n\t\t\t\t}\n\t\t\t}\n\t\t\t//console.log(this.Vlt.ConnData);\n\n\n\t\t\t//add the connections to each node\n\t\t\tfor (let key in this.Vlt.Nodes){\n\t\t\t\tif (! this.Vlt.Nodes.hasOwnProperty(key))\n\t\t\t\t\tcontinue;\n\t\t\t\tlet z  = ((this.Vlt.Locs[key][2]-1)<this.Vlt.zRange[0]?this.Vlt.zRange[0]:(this.Vlt.Locs[key][2]-1));\n\t\t\t\t//copy the array to select from \n\t\t\t\tlet cpy = this.Vlt.Levels[z].map((value)=>{return value});\n\t\t\t\tdo {\n\t\t\t\t\tlet idx = Math.floor(Math.random()*cpy.length);\n\t\t\t\t\tthis.Vlt.Nodes[key].Connections.push(cpy.splice(idx,1)[0]);\n\t\t\t\t}\n\t\t\t\twhile (this.Vlt.Nodes[key].Connections.length<this.Vlt.ConnData[z+1].NumberBelow)\n\t\t\t}\n\n\t\t\t//console.log(this.Vlt.Nodes);\n\n\n\n\n\n\n\n\n\t\t\tfun(null,com);\n\t\t}\n\t\tSaveNetwork(com, fun) {\n\t\t\tthis.Vlt.Par.Nodes = this.Par.Vlt.Nodes;\n\t\t\tthis.SaveNetwork();\n\t\t\t\n\t\t\tfun(null, com);\n\t\t}\n\t\tGetNetwork(com, fun){\n\t\t\tconsole.log(\"--ViewBuilder/GetNetwork\");\n\t\t\tcom.Network = this.Vlt.Nodes;\n\n\t\t\tfun(null, com);\n\t\t}\n\t}\n\n\treturn {\n\t\tdispatch: ViewBuilder.prototype\n\t};\n\n})();",
  "package.json": "{\n  \"name\": \"render-controller\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"RenderController.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"dependencies\": {\n    \"async\": \"^2.5.0\"\n  }\n}\n",
  "schema.json": "{\n\t\"Apex\": {\n\t\t\"Entity\": \"ViewBuilder.js\",\n\t\t\"$Setup\": \"Setup\"\n\t}\n}",
  "ModName": "Scrapyard.Modules.ViewBuilder",
  "Setup": "Setup"
}